{"componentChunkName":"component---src-pages-300-integration-dent-deletion-demo-script-sandbox-mdx","path":"/300-integration-dent-deletion/demo-script-sandbox/","result":{"pageContext":{"frontmatter":{"title":"Cloud-native integration deployment 300-level live demo","description":"Dent deletion 300-level live demo","tabs":["Demo preparation","Demo script"]},"relativePagePath":"/300-integration-dent-deletion/demo-script-sandbox.mdx","titleType":"page","MdxNode":{"id":"16c5eaec-5e2d-59af-8c50-2f2fc0234643","children":[],"parent":"1bcd7b7a-8dfa-52c3-bf0f-001e24a9836c","internal":{"content":"---\ntitle: Cloud-native integration deployment\n  300-level live demo\ndescription: Dent deletion 300-level live demo\ntabs: [ 'Demo preparation', 'Demo script']\n---\n\nexport const Title = () => (\n  <span>\n      Cloud-native integration deployment <br/> 300-level live demo\n  </span> );\n\n![Dent Deletion banner](./images/cloud-native-integration-300-script-banner.jpg)\n\n<span id=\"top\"></span>\n\n<details>\n\n<summary>Introduction</summary>\n\n<br/>\n\nWe’re going to demonstrate automating deployment of a complex integration solution using a pipeline. This enables faster, more frequent delivery of changes into production and improves deployment confidence. We will also see how container-based platforms enable operational consistency and automation, simplifying administration of an environment.\n\n<br/>\n\nOur scenario features an insurance broker gathering insurance quotes from multiple companies and providing an aggregated list to customers via an API. This involves multiple integration styles, including application integration, API management, and messaging. Our goal is automated deployment and operations for the process.\n\n<br/>\n\nWe will begin with a simple deployment of a single integration that retrieves a quote from an insurer. Later, we will explore a more complex solution, with multiple integration abilities that we want to deploy together - including integration flows, queues, and managed APIs.\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>1 - Accessing the environment</summary>\n\n<br/>\n\n| **1.1** | **Log into Cloud Pak for Integration** |\n| :--- | :--- |\n| **Narration** | Let’s see IBM Cloud Pak for Integration in action. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |\n| **Action** &nbsp; 1.1.1 | Open Cloud Pak for Integration and click **IBM provided credentials (admin only)**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-1-1.png\" width=\"800\" /> |\n| **Narration** | Let's log in to a cloud version on IBM Cloud. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n| **Action** &nbsp; 1.1.2 | **Log in** with your admin **username** and **password**.  <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-1-2.png\" width=\"800\" /> |\n\n| **1.2** | **View the Cloud Pak for Integration home screen** |\n| :--- | :--- |\n| **Narration** | This is the IBM Cloud Pak for Integration home screen, which shows all the capabilities of the pak in one place. Specialized integration capabilities for API management, application integration, messaging, and more, are built on top of powerful automation services.<br/><br/> Let’s see the integration capabilities available. |\n| **Action** &nbsp; 1.2.1 | From the **Home Page**, click **Integration instances** (if necessary, close the tour dialog).<br/><br/>If you don't see the Integration instances tile, open the top left menu and select **Administration** and then **Integration instances**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-2-1.png\" width=\"800\" /> |\n\n| **1.3** | **Access integration capabilities** |\n| :--- | :--- |\n| **Narration** | You are able to access all the integration capabilities your team needs through a single interface, including API management, application integration, enterprise messaging, events, and high-speed transfer. To automate customer interactions in this demo, we will use App Connect for application integration, API Connect for API management, and the Message Queue for Enterprise Messaging.<br/><br/>Let’s open our App Connect Dashboard. |\n| **Action** &nbsp; 1.3.1 | Show the **Integration instances** page, then click the **Integration dashboard** (ace-dashboard-demo). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-3-1.png\" width=\"800\" /><br/> |\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>2 - Deploying your integration </summary>\n\n<br/>\n\n| **2.1** | **Create an integration server** |\n| :--- | :--- |\n| **Narration** | We’ll create an integration server for our new integration deployment. Each integration server is deployed in a separate container. |\n| **Action** &nbsp; 2.1.1 | Click **Create a server**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-1-1.png\" width=\"800\" /> |\n\n| **2.2** | **Import the BAR file** |\n| :--- | :--- |\n| **Narration** | We're now going to deploy an integration that we've already created in the App Connect toolkit. We simply drag and drop it into the console straight from the file system. If we’ve loaded the bar file before, it will be available from an internal asset repository. |\n| **Action** &nbsp; 2.2.1 | Select **Quick start toolkit integration** (1). Click **Next** (2). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.2.2 | Upload the **HTTPEchoApp.bar** BAR file (1) that you downloaded during demo preparation. Click **Next** (2). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-2-2.png\" width=\"800\" /> |\n\n| **2.3** | **Configure your integration server** |\n| :--- | :--- |\n| **Narration** | We are then asked if we would like to apply any specific configuration information to this particular deployment, such as user credentials or certificates that are required to integrate to a particular backend system.<br/><br/>This might include credentials to the downstream insurance quotation engine. These are held within Kubernetes in standard mechanisms known as ConfigMaps and Secrets, with visibilility limited to those with correct permissions to view, upload and change credentials. <br/><br/>This is particularly important in integration scenarios - such as our insurance brokerage example - which have credentials enabling access to multiple third-party insurers. Those systems may provide access to sensitive personal data. The insurers may be charging the broker for access to their API, or conversely, providing commission on quotes that are followed up. Misuse of the credentials could have all manner of undesired effects. |\n| **Action** &nbsp; 2.3.1 | Click **Next**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-3-1.png\" width=\"800\" /> |\n| **Narration** | We need to fill in a form to populate a file used during deployment. The file has the details about how your integration will be deployed and operated. We can decide the version of the runtime that we want the integration to run against, and that is specific to this particular integration. Another integration might be running against a different version that it was tested against. <br/><br/>This is also where we decide how many replicas of the integration container we want. In a traditional installation, all integrations would inherit the same characteristics of the high availability pair of the centralised servers. In our scenario, our customers might be particularly sensitive to outages, so we might decide to minimize the availabiltiy impact of any runtime failures by increasing the number of container replicas to \"3\", or \"5, or \"7\".<br/><br/>We can also change the amount of memory assigned to the container if we knew the data model for the insurance quotation was particularly large and therefore memory intensive. |\n| **Action** &nbsp; 2.3.2 | Name the integration server **simple-echo-app** (1). Change the **Replicas** number to **3** (2). Open the **YAML editor** (3).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-3-2.png\" width=\"800\" /> |\n| **Narration** | This form is just a graphical way of editing the yaml formatted deployment properties file. You can see it's updating that text file, and setting the number of replicas to \"3\". This file is known as the “custom resource definition” for the integration. It's used to instantiate this integration using command line tools, or by calling one of the OpenShift APIs, or from a pipeline - as we will do later in this demonstration. |\n| **Action** &nbsp; 2.3.3 | Open the **Common settings** tab. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-3-3.png\" width=\"800\" /> |\n\n| **2.4** | **Explore server creation** |\n| :--- | :--- |\n| **Narration** | Let's create that server. |\n| **Action** &nbsp; 2.4.1 | Click **Create**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-1.png\" width=\"800\" /> |\n| **Narration** | We can see a new server appear, but it hasn't started up yet. Behind the scenes, Kubernetes has received all the instructions it needs to start up – what image to download, how much CPU and memory to provide to it, and other parameters. It’s also been asked to create three replicas of the server and load balance between them. |\n| **Action** &nbsp; 2.4.2 | Explore the server creation dashboard. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-2.png\" width=\"800\" /> |\n| **Narration** | Let's take a quick look at what Kubernetes is doing based on our instructions. There is a set of three pods starting up, which houses the containers that integrate with our insurer. Those could have been created from a normal Kubernetes command line, using the same custom resource definition file, or (as we’ll see later,) by a pipeline that calls the Kubernetes APIs.<br/><br/>It's easy to transition from a manual deployment to creating a scripted, automated deployment using this interface. |\n| **Action** &nbsp; 2.4.3 | Open the Openshift Web Console. On the left menu, select **Workloads**, then **Pods** (1). Select **cp4i** project (2). Show the simple-echo-app pods creation (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-3.png\" width=\"800\" /> |\n| **Narration** | The App Connect dashboard displays the integration up and running with three replicas. Kubernetes manages high availability implicitly and will ensure there are always three. If one of the replicas fail, Kubernetes will reinstate a new one in its place. |\n| **Action** &nbsp; 2.4.4 | Return to the App Connect dashboard page. Click **simple-echo-app server**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-4.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.4.5 | Open the **HTTPEcho** application. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-5.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.4.6 | Open the **Echo** message flow. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-6.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.4.7 | Explore the **Echo properties** page. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-7.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>3 - Exploring the pipeline </summary>\n\n<br/>\n\n| **3.1** | **Create the pipeline** |\n| :--- | :--- |\n| **Narration** | The insurance broker now wants quotations from three different companies, which will require integration capabilities such as integration flows, queues, and managed APIs.<br/><br/>- Each insurance company has its own way of exposing their quotation system, so we have to build integration flows in App Connect to help us request those quotes and pull back the answers in a form we can use.<br/><br/>- The API needs to be responsive, handling as many quotations as possible, as quickly as possible. <br/><br/>- These integrations and queuing capabilities need to scale independently, but deploy as a single solution. Deploying in a fine-grained way using container means independent updating and scaling,  things independently. They can deploy the complete solution in a consistent way through one CICD pipeline.<br/><br/> - The companies want to make integration data available via an API so insurance partners can build this into their systems. If they can expose those APIs through an API management system, it will be easier for partners to onboard themselves to use the APIs, and potentially monetize them.<br/><br/>We're going to use the Kubernetes native Tekton pipeline capability that comes as part of OpenShift to deploy our whole insurance integration solution. Here on my machine I forked and cloned a github project with the pipeline. Let's execute a script to create the pipeline in my Openshift environment. |\n| **Action** &nbsp; 3.1.1 | Open a Terminal Window and go to the cp4i-deployment-samples folder cloned in the demo preparation section. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.1.2 | Go to the **DrivewayDentDeletion/Operators** folder (**cd DrivewayDentDeletion/Operators/**). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.1.3 | Execute the cicd-apply-test-apic-pipeline.sh.<br/> <br/><InlineNotification><strong>NOTE</strong>: Before you execute the script below, ensure that you are already logged in your Openshift environment using OC command line tool, as covered in the Preparation section.</InlineNotification> <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.1.4 | As part of the result script, you should see the webhook URL. Copied it. You will use it in next step. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-4.png\" width=\"800\" /> |\n\n| **3.2** | **Explore the pipeline** |\n| :--- | :--- |\n| **Narration** | Now, let's open the OpenShift Console to check the Pipeline that  we created in the cp4i project. |\n| **Action** &nbsp; 3.2.1 | Back to Openshift Web Console, open **Pipelines**, then **Pipelines**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.2.2 | Filter by **cp4i project**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.2.3 | Open **test-apic-pipeline**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-3.png\" width=\"800\" /> |\n| **Narration** | As you can see, we specified a pipeline with multiple tasks that build multiple integration images AND a queue manager, and also configures some API exposure. The pipeline then deploys these to a test environment, performs some tests, and upon successful completion of the test, deploys into the main environment. |\n| **Action** &nbsp; 3.2.4 | Explore **test-apic-pipeline**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-4.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>4 - Initiating the pipeline from Git </summary>\n\n<br/>\n\n| **4.1** | **Configure the webhook** |\n| :--- | :--- |\n| **Narration** | To make it a bit more realistic, source code is stored in a source code repository – in this case Git. We're going to set up a web hook on Git which will trigger our Tekton pipeline whenever we make a commit to the code. <br/><br/>Note that it is not just the integration code that could trigger a build. It could also be a change to an MQ Configuration, or a change to the definition of an API.<br/><br/>Our insurance broker now has even greater confidence in the consistency of what is in production as the code repository contains absolutely everything required to re-create it. If something happens in production, the code repository shows exactly what changes were recently made, whether infrastructure of integration code. Our broker could also easily build an exact replica of the whole solution to safely diagnose the problem.  <br/><br/>Perhaps one of the most attractive features of this approach is that there is a complete configuration to roll back to a previous version. Imagine how much more comfortable you would be deploying a new business feature, if you knew you could get back to your previous state, rapidly, and with precision.<br/><br/>Here in the Webhook page, we just need to input our webhook URL and define the content type as JSON. Our webhook will \"fire\" immediately we create it. |\n| **Action** &nbsp; 4.1.1 | Open the github project you forked during Demo preparation and click **Settings**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 4.1.2 | Click **Webhooks**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 4.1.3 | Click **Add Webhook**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 4.1.4 | In the Payload URL, paste the **webhook address** (1). Change the content type to **application/json** (2). Click **Add webhook** (3).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-4.png\" width=\"800\" /> |\n\n| **4.2** | **Check the pipeline run** |\n| :--- | :--- |\n| **Narration** | Let's check our pipeline. Tekton is well suited to deploy cloud native solutions, and is itself a cloud native application. It runs on the Kubernetes platform in containers, and directly leverages the rapid deployment and scalability of containers to run pipelines. |\n| **Action** &nbsp; 4.2.1 | Back to OpenShift Web console, click  **Pipelines**, then the **Pipeline Runs** tab. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-2-1.png\" width=\"800\" /> |\n| **Narration** | We can see our pipeline has been started, and we have a high-level view of its progress. |\n| **Action** &nbsp; 4.2.2 | Open the pipeline diagram. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-2-2.png\" width=\"800\" /> |\n| **Narration** | You can see there's a nice visualization of the pipeline doing its work all the way through to the testing piece in the middle. <br/><br/>The pipeline diagram shows our progress through the build, test, and then deployment to two different environments. We can see it has been initiated, and the builds of the various images are taking place. |\n| **Action** &nbsp; 4.2.3 | Explore the pipeline diagram page. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-2-3.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>5 - Confirming the deployment </summary>\n\n<br/>\n\n| **5.1** | **Check the App Connect deployment** |\n| :--- | :--- |\n| **Narration** | Kubernetes is building a brand new topology unique to this integration solution on the fly, with queues, integrations and managed APIs, and ensuring that they are all able to connect to one another. Furthermore, it is then creating replicas for availability and performance, and implementing the load balancing across them.<br/><br/>For our insurance broker this means that this integration solution is completely independent of all their other integrations. They can re-build the whole thing at will, scale it up or down, refresh the underlying runtimes with new fix paks with no fear that they might disrupt some other part of their business.<br/><br/>Recall that part of the pipeline introduced a set of tests that had to be passed before the solution could be deployed to a second environment. Let’s consider what those tests might be doing.<br/><br/>For our integration brokerage scenario, we can imagine just how complex the testing could be. We might be setting up stubs to make calls against in the background. We might be bringing performance test capabilities to push load into the system. Then we need to tear all of that down before we then go onto the next step of finally evaluating the test results and then deciding whether to push into the target environment. This is one of the real beauties of the elastic nature of container environments. Test environments can be created on demand, and torn down once their purpose has expired.<br/><br/>After only a short while we will see that the integration servers for our solutions are started, but what about the rest of our insurance integration solution. |\n| **Action** &nbsp; 5.1.1 | Open the App Connect Dashboard Server page. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.1.2 | Show the **ddd-dev-ace servers**. If you don't see them, refresh the page.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-1-2.png\" width=\"800\" /> |\n\n| **5.2** | **Check the queue deployment in MQ explorer** |\n| :--- | :--- |\n| **Narration** | Navigating to the messaging capability, we can see that new queue managers have been created with the appropriate queues. These will allow the aggregating integration to initiate all the quotation requests to the insurers in parallel. |\n| **Action** &nbsp; 5.2.1 | Open **Menu** (1). Select **Run** (2), then **Messaging** (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.2.2 | Show the **mq-dd-qm-dev** server. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-2-2.png\" width=\"800\" /> |\n\n| **5.3** | **Check the API deployment** |\n| :--- | :--- |\n| **Narration** | Navigating to API management Portal, we can see the APIs have been deployed into the appropriate Products.<br/><br/>Potential partners who want to use the insurance brokers new aggregation API will be able to come to the portal and self-subscribe to use it.<br/><br/>It’s worth noting that as we navigated between different underling components we remained in the same user interface, logged in as the same user, and we saw a consistent look and feel to the way each of the components was administered. Furthermore, the navigation and administration capabilities are all governable by a common role based access control mechanism inherited from the underlying OpenShift platform. |\n| **Action** &nbsp; 5.3.1 | Open **Menu** (1). Click **Run** (2), then **API** (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.3.2 | Select **Common Services User Registry**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.3.3 | Check that you are using **main-demo** organization (1). If not, click **Organization** combobox and select the other organization available (2).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.3.4 | Click **Develop APIs and products**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-4.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>6 - Demonstrating availability and scalability </summary>\n\n<br/>\n\n| **6.1** | **Scale up the replicas** |\n| :--- | :--- |\n| **Narration** | Let’s imagine that our new insurance brokerage API is much more popular than we expected. We might want to scale up the number of replicas of the integration server to handle the load.<br/><br/>For simplicity, we will edit the custom resource definition directly through the UI so we can quickly see the scaling taking place. However, note that in a real scenario we would probably now do this in the source code repository and let the GitOps pipeline bring the change into production.<br/><br/>We will change the number of replicas, and say move it from three to four. That provides a \"future state” requirements and the underlying Kubernetes infrastructure will now do all the operational work needed to get it to that new state. No infrastructure expansion project, no manual infrastructure changes, just a change of a number in a file. |\n| **Action** &nbsp; 6.1.1 | Open **Menu** (1) and select **Run** (2) > **Integration** (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.2 | Open **Servers**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.3 | Click the **ddd-dev-ace-api** (1) context menu and select **Edit** (2).  <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.4 | Type **4** in the **Replicas** field (1). Click **Update** (2). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-4.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.5 | Ono the OpenShift Web Console page, open the **Workloads > Pods** page (1), filter by **cp4i** project (2) and show the four pods of the ddd-dev-ace-api (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-5.png\" width=\"800\" /> |\n\n| **6.2** | **Show high availability** |\n| :--- | :--- |\n| **Narration** | Finally, we're going to emulate a failure by deleting one of the pods that looks after the integration containers and watching it come back up again. We will see Kubernetes and OpenShift doing its job, making sure that that state that we've requested matches with what is actually deployed and running. That promise of operational reliability is not something you have to build in, it is just fundamental to the way that Kubernetes works. | \n| **Action** &nbsp; 6.2.1 | On Openshift Web Console Pods page, click the context menu of a ddd-dev-ace-api pod and select **Delete Pod** (2).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.2.2 | Show the recreation of the pod.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-2-2.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>Summary </summary>\n\n<br/>\n\nIn this demonstration an insurance broker automated deployment and operations for an API  providing an aggregated list of insurance quotes to customers. The API worked with application integration, API management, messaging, and multiple integration styles. With Kubernetes handling much of the daily infrastructural and operational tasks, the broker was able to focus on defining and implimenting other value add-on features for customers.\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n","type":"Mdx","contentDigest":"e43b40fd8799a0d0550668b63e8ddd33","owner":"gatsby-plugin-mdx","counter":2370},"frontmatter":{"title":"Cloud-native integration deployment 300-level live demo","description":"Dent deletion 300-level live demo","tabs":["Demo preparation","Demo script"]},"exports":{},"rawBody":"---\ntitle: Cloud-native integration deployment\n  300-level live demo\ndescription: Dent deletion 300-level live demo\ntabs: [ 'Demo preparation', 'Demo script']\n---\n\nexport const Title = () => (\n  <span>\n      Cloud-native integration deployment <br/> 300-level live demo\n  </span> );\n\n![Dent Deletion banner](./images/cloud-native-integration-300-script-banner.jpg)\n\n<span id=\"top\"></span>\n\n<details>\n\n<summary>Introduction</summary>\n\n<br/>\n\nWe’re going to demonstrate automating deployment of a complex integration solution using a pipeline. This enables faster, more frequent delivery of changes into production and improves deployment confidence. We will also see how container-based platforms enable operational consistency and automation, simplifying administration of an environment.\n\n<br/>\n\nOur scenario features an insurance broker gathering insurance quotes from multiple companies and providing an aggregated list to customers via an API. This involves multiple integration styles, including application integration, API management, and messaging. Our goal is automated deployment and operations for the process.\n\n<br/>\n\nWe will begin with a simple deployment of a single integration that retrieves a quote from an insurer. Later, we will explore a more complex solution, with multiple integration abilities that we want to deploy together - including integration flows, queues, and managed APIs.\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>1 - Accessing the environment</summary>\n\n<br/>\n\n| **1.1** | **Log into Cloud Pak for Integration** |\n| :--- | :--- |\n| **Narration** | Let’s see IBM Cloud Pak for Integration in action. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |\n| **Action** &nbsp; 1.1.1 | Open Cloud Pak for Integration and click **IBM provided credentials (admin only)**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-1-1.png\" width=\"800\" /> |\n| **Narration** | Let's log in to a cloud version on IBM Cloud. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |\n| **Action** &nbsp; 1.1.2 | **Log in** with your admin **username** and **password**.  <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-1-2.png\" width=\"800\" /> |\n\n| **1.2** | **View the Cloud Pak for Integration home screen** |\n| :--- | :--- |\n| **Narration** | This is the IBM Cloud Pak for Integration home screen, which shows all the capabilities of the pak in one place. Specialized integration capabilities for API management, application integration, messaging, and more, are built on top of powerful automation services.<br/><br/> Let’s see the integration capabilities available. |\n| **Action** &nbsp; 1.2.1 | From the **Home Page**, click **Integration instances** (if necessary, close the tour dialog).<br/><br/>If you don't see the Integration instances tile, open the top left menu and select **Administration** and then **Integration instances**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-2-1.png\" width=\"800\" /> |\n\n| **1.3** | **Access integration capabilities** |\n| :--- | :--- |\n| **Narration** | You are able to access all the integration capabilities your team needs through a single interface, including API management, application integration, enterprise messaging, events, and high-speed transfer. To automate customer interactions in this demo, we will use App Connect for application integration, API Connect for API management, and the Message Queue for Enterprise Messaging.<br/><br/>Let’s open our App Connect Dashboard. |\n| **Action** &nbsp; 1.3.1 | Show the **Integration instances** page, then click the **Integration dashboard** (ace-dashboard-demo). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-1-3-1.png\" width=\"800\" /><br/> |\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>2 - Deploying your integration </summary>\n\n<br/>\n\n| **2.1** | **Create an integration server** |\n| :--- | :--- |\n| **Narration** | We’ll create an integration server for our new integration deployment. Each integration server is deployed in a separate container. |\n| **Action** &nbsp; 2.1.1 | Click **Create a server**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-1-1.png\" width=\"800\" /> |\n\n| **2.2** | **Import the BAR file** |\n| :--- | :--- |\n| **Narration** | We're now going to deploy an integration that we've already created in the App Connect toolkit. We simply drag and drop it into the console straight from the file system. If we’ve loaded the bar file before, it will be available from an internal asset repository. |\n| **Action** &nbsp; 2.2.1 | Select **Quick start toolkit integration** (1). Click **Next** (2). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.2.2 | Upload the **HTTPEchoApp.bar** BAR file (1) that you downloaded during demo preparation. Click **Next** (2). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-2-2.png\" width=\"800\" /> |\n\n| **2.3** | **Configure your integration server** |\n| :--- | :--- |\n| **Narration** | We are then asked if we would like to apply any specific configuration information to this particular deployment, such as user credentials or certificates that are required to integrate to a particular backend system.<br/><br/>This might include credentials to the downstream insurance quotation engine. These are held within Kubernetes in standard mechanisms known as ConfigMaps and Secrets, with visibilility limited to those with correct permissions to view, upload and change credentials. <br/><br/>This is particularly important in integration scenarios - such as our insurance brokerage example - which have credentials enabling access to multiple third-party insurers. Those systems may provide access to sensitive personal data. The insurers may be charging the broker for access to their API, or conversely, providing commission on quotes that are followed up. Misuse of the credentials could have all manner of undesired effects. |\n| **Action** &nbsp; 2.3.1 | Click **Next**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-3-1.png\" width=\"800\" /> |\n| **Narration** | We need to fill in a form to populate a file used during deployment. The file has the details about how your integration will be deployed and operated. We can decide the version of the runtime that we want the integration to run against, and that is specific to this particular integration. Another integration might be running against a different version that it was tested against. <br/><br/>This is also where we decide how many replicas of the integration container we want. In a traditional installation, all integrations would inherit the same characteristics of the high availability pair of the centralised servers. In our scenario, our customers might be particularly sensitive to outages, so we might decide to minimize the availabiltiy impact of any runtime failures by increasing the number of container replicas to \"3\", or \"5, or \"7\".<br/><br/>We can also change the amount of memory assigned to the container if we knew the data model for the insurance quotation was particularly large and therefore memory intensive. |\n| **Action** &nbsp; 2.3.2 | Name the integration server **simple-echo-app** (1). Change the **Replicas** number to **3** (2). Open the **YAML editor** (3).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-3-2.png\" width=\"800\" /> |\n| **Narration** | This form is just a graphical way of editing the yaml formatted deployment properties file. You can see it's updating that text file, and setting the number of replicas to \"3\". This file is known as the “custom resource definition” for the integration. It's used to instantiate this integration using command line tools, or by calling one of the OpenShift APIs, or from a pipeline - as we will do later in this demonstration. |\n| **Action** &nbsp; 2.3.3 | Open the **Common settings** tab. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-3-3.png\" width=\"800\" /> |\n\n| **2.4** | **Explore server creation** |\n| :--- | :--- |\n| **Narration** | Let's create that server. |\n| **Action** &nbsp; 2.4.1 | Click **Create**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-1.png\" width=\"800\" /> |\n| **Narration** | We can see a new server appear, but it hasn't started up yet. Behind the scenes, Kubernetes has received all the instructions it needs to start up – what image to download, how much CPU and memory to provide to it, and other parameters. It’s also been asked to create three replicas of the server and load balance between them. |\n| **Action** &nbsp; 2.4.2 | Explore the server creation dashboard. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-2.png\" width=\"800\" /> |\n| **Narration** | Let's take a quick look at what Kubernetes is doing based on our instructions. There is a set of three pods starting up, which houses the containers that integrate with our insurer. Those could have been created from a normal Kubernetes command line, using the same custom resource definition file, or (as we’ll see later,) by a pipeline that calls the Kubernetes APIs.<br/><br/>It's easy to transition from a manual deployment to creating a scripted, automated deployment using this interface. |\n| **Action** &nbsp; 2.4.3 | Open the Openshift Web Console. On the left menu, select **Workloads**, then **Pods** (1). Select **cp4i** project (2). Show the simple-echo-app pods creation (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-3.png\" width=\"800\" /> |\n| **Narration** | The App Connect dashboard displays the integration up and running with three replicas. Kubernetes manages high availability implicitly and will ensure there are always three. If one of the replicas fail, Kubernetes will reinstate a new one in its place. |\n| **Action** &nbsp; 2.4.4 | Return to the App Connect dashboard page. Click **simple-echo-app server**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-4.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.4.5 | Open the **HTTPEcho** application. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-5.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.4.6 | Open the **Echo** message flow. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-6.png\" width=\"800\" /> |\n| **Action** &nbsp; 2.4.7 | Explore the **Echo properties** page. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-2-4-7.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>3 - Exploring the pipeline </summary>\n\n<br/>\n\n| **3.1** | **Create the pipeline** |\n| :--- | :--- |\n| **Narration** | The insurance broker now wants quotations from three different companies, which will require integration capabilities such as integration flows, queues, and managed APIs.<br/><br/>- Each insurance company has its own way of exposing their quotation system, so we have to build integration flows in App Connect to help us request those quotes and pull back the answers in a form we can use.<br/><br/>- The API needs to be responsive, handling as many quotations as possible, as quickly as possible. <br/><br/>- These integrations and queuing capabilities need to scale independently, but deploy as a single solution. Deploying in a fine-grained way using container means independent updating and scaling,  things independently. They can deploy the complete solution in a consistent way through one CICD pipeline.<br/><br/> - The companies want to make integration data available via an API so insurance partners can build this into their systems. If they can expose those APIs through an API management system, it will be easier for partners to onboard themselves to use the APIs, and potentially monetize them.<br/><br/>We're going to use the Kubernetes native Tekton pipeline capability that comes as part of OpenShift to deploy our whole insurance integration solution. Here on my machine I forked and cloned a github project with the pipeline. Let's execute a script to create the pipeline in my Openshift environment. |\n| **Action** &nbsp; 3.1.1 | Open a Terminal Window and go to the cp4i-deployment-samples folder cloned in the demo preparation section. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.1.2 | Go to the **DrivewayDentDeletion/Operators** folder (**cd DrivewayDentDeletion/Operators/**). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.1.3 | Execute the cicd-apply-test-apic-pipeline.sh.<br/> <br/><InlineNotification><strong>NOTE</strong>: Before you execute the script below, ensure that you are already logged in your Openshift environment using OC command line tool, as covered in the Preparation section.</InlineNotification> <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.1.4 | As part of the result script, you should see the webhook URL. Copied it. You will use it in next step. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-1-4.png\" width=\"800\" /> |\n\n| **3.2** | **Explore the pipeline** |\n| :--- | :--- |\n| **Narration** | Now, let's open the OpenShift Console to check the Pipeline that  we created in the cp4i project. |\n| **Action** &nbsp; 3.2.1 | Back to Openshift Web Console, open **Pipelines**, then **Pipelines**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.2.2 | Filter by **cp4i project**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 3.2.3 | Open **test-apic-pipeline**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-3.png\" width=\"800\" /> |\n| **Narration** | As you can see, we specified a pipeline with multiple tasks that build multiple integration images AND a queue manager, and also configures some API exposure. The pipeline then deploys these to a test environment, performs some tests, and upon successful completion of the test, deploys into the main environment. |\n| **Action** &nbsp; 3.2.4 | Explore **test-apic-pipeline**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-3-2-4.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>4 - Initiating the pipeline from Git </summary>\n\n<br/>\n\n| **4.1** | **Configure the webhook** |\n| :--- | :--- |\n| **Narration** | To make it a bit more realistic, source code is stored in a source code repository – in this case Git. We're going to set up a web hook on Git which will trigger our Tekton pipeline whenever we make a commit to the code. <br/><br/>Note that it is not just the integration code that could trigger a build. It could also be a change to an MQ Configuration, or a change to the definition of an API.<br/><br/>Our insurance broker now has even greater confidence in the consistency of what is in production as the code repository contains absolutely everything required to re-create it. If something happens in production, the code repository shows exactly what changes were recently made, whether infrastructure of integration code. Our broker could also easily build an exact replica of the whole solution to safely diagnose the problem.  <br/><br/>Perhaps one of the most attractive features of this approach is that there is a complete configuration to roll back to a previous version. Imagine how much more comfortable you would be deploying a new business feature, if you knew you could get back to your previous state, rapidly, and with precision.<br/><br/>Here in the Webhook page, we just need to input our webhook URL and define the content type as JSON. Our webhook will \"fire\" immediately we create it. |\n| **Action** &nbsp; 4.1.1 | Open the github project you forked during Demo preparation and click **Settings**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 4.1.2 | Click **Webhooks**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 4.1.3 | Click **Add Webhook**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 4.1.4 | In the Payload URL, paste the **webhook address** (1). Change the content type to **application/json** (2). Click **Add webhook** (3).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-1-4.png\" width=\"800\" /> |\n\n| **4.2** | **Check the pipeline run** |\n| :--- | :--- |\n| **Narration** | Let's check our pipeline. Tekton is well suited to deploy cloud native solutions, and is itself a cloud native application. It runs on the Kubernetes platform in containers, and directly leverages the rapid deployment and scalability of containers to run pipelines. |\n| **Action** &nbsp; 4.2.1 | Back to OpenShift Web console, click  **Pipelines**, then the **Pipeline Runs** tab. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-2-1.png\" width=\"800\" /> |\n| **Narration** | We can see our pipeline has been started, and we have a high-level view of its progress. |\n| **Action** &nbsp; 4.2.2 | Open the pipeline diagram. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-2-2.png\" width=\"800\" /> |\n| **Narration** | You can see there's a nice visualization of the pipeline doing its work all the way through to the testing piece in the middle. <br/><br/>The pipeline diagram shows our progress through the build, test, and then deployment to two different environments. We can see it has been initiated, and the builds of the various images are taking place. |\n| **Action** &nbsp; 4.2.3 | Explore the pipeline diagram page. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-4-2-3.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>5 - Confirming the deployment </summary>\n\n<br/>\n\n| **5.1** | **Check the App Connect deployment** |\n| :--- | :--- |\n| **Narration** | Kubernetes is building a brand new topology unique to this integration solution on the fly, with queues, integrations and managed APIs, and ensuring that they are all able to connect to one another. Furthermore, it is then creating replicas for availability and performance, and implementing the load balancing across them.<br/><br/>For our insurance broker this means that this integration solution is completely independent of all their other integrations. They can re-build the whole thing at will, scale it up or down, refresh the underlying runtimes with new fix paks with no fear that they might disrupt some other part of their business.<br/><br/>Recall that part of the pipeline introduced a set of tests that had to be passed before the solution could be deployed to a second environment. Let’s consider what those tests might be doing.<br/><br/>For our integration brokerage scenario, we can imagine just how complex the testing could be. We might be setting up stubs to make calls against in the background. We might be bringing performance test capabilities to push load into the system. Then we need to tear all of that down before we then go onto the next step of finally evaluating the test results and then deciding whether to push into the target environment. This is one of the real beauties of the elastic nature of container environments. Test environments can be created on demand, and torn down once their purpose has expired.<br/><br/>After only a short while we will see that the integration servers for our solutions are started, but what about the rest of our insurance integration solution. |\n| **Action** &nbsp; 5.1.1 | Open the App Connect Dashboard Server page. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.1.2 | Show the **ddd-dev-ace servers**. If you don't see them, refresh the page.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-1-2.png\" width=\"800\" /> |\n\n| **5.2** | **Check the queue deployment in MQ explorer** |\n| :--- | :--- |\n| **Narration** | Navigating to the messaging capability, we can see that new queue managers have been created with the appropriate queues. These will allow the aggregating integration to initiate all the quotation requests to the insurers in parallel. |\n| **Action** &nbsp; 5.2.1 | Open **Menu** (1). Select **Run** (2), then **Messaging** (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.2.2 | Show the **mq-dd-qm-dev** server. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-2-2.png\" width=\"800\" /> |\n\n| **5.3** | **Check the API deployment** |\n| :--- | :--- |\n| **Narration** | Navigating to API management Portal, we can see the APIs have been deployed into the appropriate Products.<br/><br/>Potential partners who want to use the insurance brokers new aggregation API will be able to come to the portal and self-subscribe to use it.<br/><br/>It’s worth noting that as we navigated between different underling components we remained in the same user interface, logged in as the same user, and we saw a consistent look and feel to the way each of the components was administered. Furthermore, the navigation and administration capabilities are all governable by a common role based access control mechanism inherited from the underlying OpenShift platform. |\n| **Action** &nbsp; 5.3.1 | Open **Menu** (1). Click **Run** (2), then **API** (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.3.2 | Select **Common Services User Registry**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.3.3 | Check that you are using **main-demo** organization (1). If not, click **Organization** combobox and select the other organization available (2).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 5.3.4 | Click **Develop APIs and products**.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-5-3-4.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>6 - Demonstrating availability and scalability </summary>\n\n<br/>\n\n| **6.1** | **Scale up the replicas** |\n| :--- | :--- |\n| **Narration** | Let’s imagine that our new insurance brokerage API is much more popular than we expected. We might want to scale up the number of replicas of the integration server to handle the load.<br/><br/>For simplicity, we will edit the custom resource definition directly through the UI so we can quickly see the scaling taking place. However, note that in a real scenario we would probably now do this in the source code repository and let the GitOps pipeline bring the change into production.<br/><br/>We will change the number of replicas, and say move it from three to four. That provides a \"future state” requirements and the underlying Kubernetes infrastructure will now do all the operational work needed to get it to that new state. No infrastructure expansion project, no manual infrastructure changes, just a change of a number in a file. |\n| **Action** &nbsp; 6.1.1 | Open **Menu** (1) and select **Run** (2) > **Integration** (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.2 | Open **Servers**. <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-2.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.3 | Click the **ddd-dev-ace-api** (1) context menu and select **Edit** (2).  <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-3.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.4 | Type **4** in the **Replicas** field (1). Click **Update** (2). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-4.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.1.5 | Ono the OpenShift Web Console page, open the **Workloads > Pods** page (1), filter by **cp4i** project (2) and show the four pods of the ddd-dev-ace-api (3). <br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-1-5.png\" width=\"800\" /> |\n\n| **6.2** | **Show high availability** |\n| :--- | :--- |\n| **Narration** | Finally, we're going to emulate a failure by deleting one of the pods that looks after the integration containers and watching it come back up again. We will see Kubernetes and OpenShift doing its job, making sure that that state that we've requested matches with what is actually deployed and running. That promise of operational reliability is not something you have to build in, it is just fundamental to the way that Kubernetes works. | \n| **Action** &nbsp; 6.2.1 | On Openshift Web Console Pods page, click the context menu of a ddd-dev-ace-api pod and select **Delete Pod** (2).<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-2-1.png\" width=\"800\" /> |\n| **Action** &nbsp; 6.2.2 | Show the recreation of the pod.<br/><br/><img src=\"https://raw.githubusercontent.com/ibm-garage-tsa/platinum-demos/master/src/pages/300-integration-dent-deletion/images/dent-deletion-6-2-2.png\" width=\"800\" /> |\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n\n<details>\n\n<summary>Summary </summary>\n\n<br/>\n\nIn this demonstration an insurance broker automated deployment and operations for an API  providing an aggregated list of insurance quotes to customers. The API worked with application integration, API management, messaging, and multiple integration styles. With Kubernetes handling much of the daily infrastructural and operational tasks, the broker was able to focus on defining and implimenting other value add-on features for customers.\n\n<br/>\n\n**[Go to top](#top)**\n\n</details>\n","fileAbsolutePath":"/home/runner/work/platinum-demos/platinum-demos/src/pages/300-integration-dent-deletion/demo-script-sandbox.mdx"}}},"staticQueryHashes":["1364590287","137577622","137577622","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","768070550"]}